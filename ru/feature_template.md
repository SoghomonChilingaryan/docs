# Шаблон фичи (копируй и используй)

## Когда создавать модуль фичи

Создавай `lib/src/features/<feature_name>`, когда:
- у UI есть свое состояние и бизнес-правила
- у фичи есть свои источники данных или репозитории
- фичу можно разрабатывать/тестировать изолированно

## Структура

Структура не должна быть жесткой ради структуры. Добавляй подпапки только когда в них есть смысл.

```
lib/src/features/<feature_name>/
  domain/
    entities/             # (опционально) если фиче нужны свои domain-объекты
    repositories/         # контракты репозиториев (абстракции)
    usecases/             # (опционально) если стало много логики оркестрации
  data/
    repositories/         # реализации репозиториев (RepositoryImpl)
  bloc/
    <feature_name>_bloc.dart
    <feature_name>_event.dart
    <feature_name>_state.dart
  screens/
  widgets/
```

Если фича **не ходит во внешний мир** (нет HTTP/storage/SDK/платформы/remote config/аналитики), можно начать без `domain/` и `data/`:

- `bloc/ + screens/ + widgets/` (и максимум pure Dart helpers внутри фичи).

Если фича **ходит во внешний мир**, `domain/repositories` обязателен: BLoC зависит только от контракта, а реализация живет в `data/`.

## Ответственность по слоям

- `domain/entities`: pure Dart объекты (без Flutter), которые относятся к этой фиче и используются внутри этой фичи.
- `domain/repositories`: контракты (абстрактные классы/интерфейсы), без зависимостей на Flutter/SDK.
- `domain/usecases`: опциональная оркестрация. Если usecase не дает ценности, можно без него.
- `data/repositories`: реализации репозиториев (RepositoryImpl). Здесь живут внешние вызовы (server/local storage/SDK) и маппинг в domain-friendly типы.
- `bloc`: презентационная логика. Должен состоять из трех файлов: bloc / event / state.
- `screens`: экраны фичи, то есть виджеты-страницы, которые становятся target навигации (route destination).
- `widgets`: переиспользуемые виджеты фичи (составные компоненты), которые используются на экранах этой же фичи.

## BLoC: правила (строго)

- В `bloc/` всегда ровно 3 файла:
  - `<feature_name>_bloc.dart`
  - `<feature_name>_event.dart`
  - `<feature_name>_state.dart`
- BLoC должен быть pure Dart и не зависеть от Flutter-фреймворка:
  - запрещены импорты `package:flutter/...` в этих трех файлах
  - допустимы `package:bloc/bloc.dart`, `package:equatable/equatable.dart` и аналогичные Dart-only зависимости
  - исключение по необходимости: `package:flutter/foundation.dart` (например, `kDebugMode`), но не `material.dart`/`widgets.dart`
- `BuildContext`, `Navigator`, `Theme`, `MediaQuery` и любые виджеты: только в `screens/` и `widgets/`.
- Связка с Flutter делается снаружи: `BlocProvider/BlocBuilder` живут в UI слое, а не внутри BLoC.
- Единственный способ взаимодействия с BLoC снаружи: отправлять события (`add(<Feature>Event)`).
  - Не вызываем публичные методы BLoC для бизнес-логики и изменений состояния.

Рекомендация по обработке событий:

- В большинстве фич удобно держать один `on<FeatureEvent>` и обрабатывать события через `switch (event) { ... }`.
  - Это упрощает контроль потока и уменьшает шанс "гонок" из разных обработчиков, которые эмитят состояние параллельно.
  - Если для конкретного события нужна особая стратегия (например, `restartable`, `droppable`), тогда выносим его в отдельный `on<SpecificEvent>` осознанно.
- Любой доступ к внешним источникам делается только через репозиторий:
  - сервер / HTTP
  - local storage
  - SDK/сервисы (например, аудио/видео плееры и т.п.)
  - BLoC зависит от контракта репозитория (из `domain/repositories`).
  - Реализация: `FeatureRepositoryImpl` в `data/repositories`.
- `state` хранит данные и статус фичи.
  - Практически вся информация, которая нужна UI этой фичи, должна жить в `state` (а не вычисляться/тянуться напрямую из UI).
  - `state` должен оставаться Flutter-free: никаких `BuildContext`, `Widget`, `Color`, `TextStyle` и т.п.
- Все внутренние функции BLoC делаем приватными.
  - Хелперы, маппинги, обработчики событий: `_private` методы внутри `<feature_name>_bloc.dart`.
- Все зависимости BLoC храним в приватных полях.
  - Рекомендация: `final Type _dep;` инициализировать в конструкторе.
  - Это не обязательное требование, но помогает: не смешивать зависимости с публичным API BLoC и удерживать поверхность класса минимальной.

## Репозиторий и слои: зачем

Практический смысл разделения:

- `domain/`: место, где описано "что умеет фича" (контракты и сущности), без Flutter/SDK.
- `data/`: место, где живет код для внешних источников и интеграций (server/local storage/SDK). Здесь живет `RepositoryImpl`, который реализует контракт из `domain/`.
- `repository`: точка входа во внешний мир для BLoC. BLoC не ходит наружу напрямую, а просит репозиторий "дай данные/сохрани/выполни".
- `domain/repositories`: контракты репозиториев. Нужны, чтобы UI/BLoC не знали о реализации.
- `domain/entities` (опционально): сложные типы, которые живут внутри фичи и не должны зависеть от Flutter.

Как это связывается (типовой поток):

- Репозиторий создается на уровне сборки приложения (composition root).
  - Обычно через контейнер зависимостей: в репозиторий прокидываются все нужные клиенты (API, local storage, SDK и т.д.).
- BLoC/Cubit создается в UI слое (обычно в `screens/`) и получает репозиторий через конструктор.
  - Это может быть через `BlocProvider` или вручную в `initState` (если нужно контролировать создание/уничтожение через lifecycle экрана).
- Если BLoC нужен внешний источник: он вызывает метод репозитория, получает результат и дальше обновляет `state`.

Важно:

- BLoC/Cubit не должен создавать/доставать внешние зависимости сам (`SharedPreferences.getInstance()`, `Dio()`, `Firebase.*`, platform channels и т.п.).
- Все это делается в `data/` и связывается через DI.

## Репозиторий: рекомендации

- Держим репозиторий с минимальным публичным API: только методы, которые реально нужны BLoC.
- Все зависимости репозитория так же держим в приватных полях (как в BLoC).
- Рекомендация: зависимости передаем через `required` named params конструктора и сохраняем в `final` `_private` поля.

Про storage для небольших настроек:

- Если нужно хранить небольшие настройки (тема/локаль/флаги), репозиторий в `data/` должен использовать минимальный интерфейс `AppPreferencesStorage` (из `lib/src/common/storage`).
- Конкретная реализация (SharedPreferences/Hive и т.п.) живет в `common/storage` и подключается через DI.
- Важно: BLoC/Cubit по-прежнему не должен импортировать/дергать конкретный storage. Только контракт репозитория из `domain/repositories`.

Если storage-объект уже существует:

- В разных проектах этот интерфейс может называться по-разному (`PreferencesStorage`, `KeyValueStorage`, и т.п.).
- Если в проекте уже есть такой общий объект, **не создаем новый**. Просто используем существующий и подключаем его через DI.

## UI: `screens/` и `widgets/`

Что куда класть:

- `screens/`: экраны (route destinations). Если у фичи есть свой экран, он живет здесь.
- `widgets/`: внутренние виджеты фичи (части экрана), которые переиспользуются в рамках этой фичи.

Как писать `Screen`:

- Если экран большой, его нужно декомпозировать на отдельные виджеты.
  - Идея: открыть `Screen` и увидеть "дерево секций", где каждая секция делает одну работу.
- Почти никогда не создаем функции типа `Widget _buildHeader()` или `Widget header()`.
  - Вместо этого делаем отдельные `StatelessWidget` (часто приватные) с понятным названием.
- Декомпозиция "сверху вниз" по слоям/секциям:
  - `<Feature>Header`
  - `<Feature>Form`
  - `<Feature>Card`
  - `<Feature>List`
  - `<Feature>Actions`
- Разделители/отступы между секциями делаем отдельными виджетами (`SizedBox(...)` или аналог), а не "магией" внутри соседних секций.

State management в UI:

- Если BLoC/Cubit нужен только на время жизни этого экрана, создаем его в `initState` экрана.
  - Это гарантирует, что при уходе со страницы BLoC/Cubit будет уничтожен вместе с виджетом.
  - Если BLoC/Cubit создан вручную в `initState`, его нужно закрыть в `dispose` (`await` не нужен).

Про Cubit:

- Cubit разрешен (как облегченный BLoC), но для него действуют те же правила слоев и зависимостей:
  - Cubit не импортирует Flutter.
  - Cubit не ходит во внешний мир напрямую.
  - Cubit зависит только от `domain/repositories` контрактов (и/или usecases).

Пример (абстрактно, без привязки к конкретной фиче):

```dart
class FeatureScreen extends StatefulWidget {
  const FeatureScreen({super.key});

  @override
  State<FeatureScreen> createState() => _FeatureScreenState();
}

class _FeatureScreenState extends State<FeatureScreen> {
  late final FeatureCubit _cubit;

  @override
  void initState() {
    super.initState();
    _cubit = FeatureCubit(
      repository: context.read<FeatureRepository>(),
      navigator: context.read<AppNavigator>(),
      // other deps...
    );
  }

  @override
  void dispose() {
    _cubit.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider.value(
      value: _cubit,
      child: const FeatureBody(), // compose from widgets/
    );
  }
}
```

Про данные внутри фичи:

- `state`: "то, что видит пользователь" и что нужно отрисовать на экране (данные + статус загрузки/ошибки).
- `event`: входные команды/намерения пользователя или системы.
- `entity`: добавляем, когда нужно передавать между частями фичи не примитивы, а более сложные классы (результаты, модели, структуры данных). `entity` всегда Dart-only.

```dart
class FeatureBloc extends Bloc<FeatureEvent, FeatureState> {
  final FeatureRepository _repository;

  FeatureBloc({
    required FeatureRepository repository,
  }) : _repository = repository;
}
```

## Нейминг (фича как единый модуль)

Имена держим консистентными по названию фичи:

- BLoC: `<Feature>Bloc`, `<Feature>Event`, `<Feature>State`
- UI: `<Feature>Screen`, `<Feature>*Widget`
- Repository contract: `<Feature>Repository` (лежит в `domain/repositories`)
- Repository implementation: `<Feature>RepositoryImpl` (лежит в `data/repositories`)

Если внутри репозитория разрастается код:

- можно добавить `data/datasources` для разделения внешних вызовов
- можно добавить `data/mappers` для явного DTO <-> domain

Но это не должно быть обязательным по умолчанию.

## Запрет на cross-feature импорты

Cross-feature import = когда фича A напрямую импортирует внутренности фичи B (особенно `data/`, `bloc/`, `screens/`, `widgets/`).

Почему это запрещаем:

- начинает расти скрытая связность между фичами (любое изменение в B ломает A)
- появляются циклы зависимостей и "цепочки" из многих фич
- фичу сложно удалить/переписать: ее код расползается импортами по проекту

Правило:

- фича не импортирует `data/` другой фичи
- в идеале фича не импортирует ничего "внутреннего" из другой фичи

Если фиче A нужны данные/возможности фичи B, варианты (по порядку предпочтения):

1) Вынести общее
- если это реально общая вещь (модель/утилита/общий UI), вынеси в `lib/src/common/*` или отдельный `packages/*`.

2) Контракт вместо реализации
- если A нужна возможность B, A должна зависеть от контракта B (абстракции), а не от реализации.
- контракт можно держать в `domain/repositories` фичи B (если вы используете `domain/`), а конкретную реализацию связывать на уровне сборки приложения.

3) Публичный API фичи (опционально)
- можно завести у фичи один "публичный" файл(ы), который экспортирует только разрешенные вещи наружу, и импортировать только его.

Дополнительно:

- Если нужно переиспользование UI между фичами, это обычно не "импорт виджета из фичи", а выделение в `lib/src/common/widgets` или отдельный `packages/<ui_kit>`.
